package codigo;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
}
:};

init with {:
    TablaSimbolos ts = new TablaSimbolos();
    

:}
terminal String Tipo;
terminal String Id;
terminal String Numero;
terminal While, Igual, Else,  Const, If, In,  Out, Main, Def, Return, Coma, Void,
    PuntoYComa, A_par, C_par, A_llave, C_llave, Op_aritmetico, Op_logico, Op_relacional, Op_booleano, String, ERROR;
non terminal P,  DECLS, DECL, INSTS, INST, ASIG, WHL, DCL, CND, ELS, IO,
    RET, DEFINICION, EXPRS, OPERADOR, LAMBDA;
non terminal Symbols.TYPE TYPE;
non terminal Symbols.EXPR EXPR;
non terminal Symbols.EXPRP EXPRP;
non terminal Symbols.EXPRS EXPRS;
non terminal Symbols.ASIGNACION ASIGNACION;
non terminal Symbols.LITERAL LITERAL;
non terminal Symbols.DEFINICION DEFINICION;
non terminal Symbols.FUNC FUNC;
non terminal Symbols.FUNCS FUNCS;
non terminal Symbols.CALL CALL;
non terminal Symbols.PARAM PARAM;
non terminal Symbols.PARAMS PARAMS;
non terminal Symbols.PARAMSP PARAMSP;

start with P;

P ::=
    DECLS:v1 Main A_llave INSTS:v2 C_llave FUNCS:v3     {: RESULT = new Symbols.P(v1, v2, v3); :}
;
DECLS ::= 
    DECL PuntoYComa:v DECLS  {: // :} |
    LAMBDA /*{:  :}*/
;
DECL ::=
    Const TYPE Id ASIGNACION /*{:  :}*/ |
    TYPE:v1 Id:v2 ASIGNACION:v3  {: Symbols.DECL decl = new Symbols.DECL(v1.valor, v2, v3.asignacion); RESULT = decl;  :}
;
TYPE ::=
    Tipo:v                      {: RESULT = new Symbols.TYPE(v):}
;
ASIGNACION ::=
    Igual EXPRP:v {:Symbols.ASIGNACION asig = new Symbols.ASIGNACION(v); RESULT = asig;  :} |
    LAMBDA /*{:  :}*/
;
INSTS ::=
    INST INSTS /*{:  :}*/ |
    LAMBDA {: :}
;
INST ::=
    ASIG PuntoYComa /*{:  :}*/ |
    WHL /*{:  :}*/ |
    DCL PuntoYComa /*{:  :}*/ |
    CND /*{:  :}*/ |
    IO PuntoYComa /*{:  :}*/ |
    CALL PuntoYComa /*{:  :}*/ |
    RET PuntoYComa /*{:  :}*/
;
ASIG ::=
    Id Igual EXPRP /*{:  :}*/
;
WHL ::=
    While A_par EXPRP C_par A_llave INSTS C_llave /*{:  :}*/
;

DCL ::= 
    TYPE Id ASIGNACION /*{:  :}*/
;
CND ::= 
    If A_par EXPRP C_par A_llave INSTS C_llave ELS /*{:  :}*/
;
ELS ::=
    Else CND /*{:  :}*/ |
    Else A_llave INSTS C_llave /*{:  :}*/ |
    LAMBDA /*{:  :}*/
;
IO ::= 
    In A_par Id C_par /*{:  :}*/ |
    Out A_par EXPRP C_par /*{:  :}*/
;
CALL ::=  
    Id:v1 A_par EXPRS:v2 C_par  {: RESULT = new CALL(v1, v2, ts);  :} |
    Id:v A_par C_par            {: RESULT = new CALL(v, ts); :}
;
RET ::= 
    Return EXPRP /*{:  :}*/
;
FUNCS ::= 
    FUNC:v1 FUNCS:v2        {: RESULTS = new Symbols.FUNCS(v1, v2); :} |
    LAMBDA                  {:  :}
;
FUNC ::= 
    DEFINICION:v1 Id:v2 A_par PARAMS:v3 C_par A_llave INSTS:v4 C_llave {: RESULT = new Symbols.FUNC(v1,v2,v3,v4,ts); :}
;
DEFINICION ::= 
    Def TYPE:v |            {: RESULT = new Symbols.DEFINICION(v);  :}
    Def Void                {: RESULT = new Symbols.DEFINICION(); :}
;
PARAMS ::= 
    PARAM:v1 PARAMSP:v2 |       {: RESULT = new Symbols.PARAMS(v1,v2); :}
    LAMBDA                      {:  :}
;
PARAMSP ::= 
    Coma PARAM:v1 PARAMSP:v2    {: RESULT = new Symbols.PARAMSP(v1, v2) :} |
    LAMBDA                      {:  :}
;
PARAM ::= 
    TYPE:v1 Id:v2           {: RESULT = new Symbols.PARAM(v1, v2); :}
;
EXPRP ::=  
    EXPRP OPERADOR EXPR /*{:  :}*/ |
    EXPR:v {:Symbols.EXPRP exprp = new Symbols.EXPRP(v); RESULT = exprp;  :}
;
EXPR ::= 
    CALL:v          {: RESULT = new Symbol.EXPR(v); :} |
    Id:v            {: RESULT = new Symbol.EXPR(v, ts); :} |
    LITERAL:v       {: RESULT = new Symbols.EXPR(v); :}
;

LITERAL ::= 
    Op_booleano     {: RESULT = new Symbols.LITERAL(Tipo.tBool) :} |
    String          {: RESULT = new Symbols.LITERAL(Tipo.tString) :} |
    Numero          {: RESULT = new Symbols.LITERAL(Tipo.tInt);  :}
;
EXPRS ::= 
    EXPRP:v1 Coma EXPRS:v2  {: RESULTADO = new EXPRS(v1, v2); :} |
    EXPRP:v                 {: RESULTADO = new EXPRS(v); :}
;
OPERADOR ::=
    Op_aritmetico | {: //RESULT = new OPERADOR(v2.type, v2.value); :}
    Op_relacional | 
    Op_logico 
;
LAMBDA ::= /* empty */;