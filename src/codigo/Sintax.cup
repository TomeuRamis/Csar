package codigo;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
}
:};

init with {:
    TablaSimbolos ts = new TablaSimbolos();
    

:}
terminal String Tipo;
terminal String Id;
terminal String Numero;
terminal While, Igual, Else,  Const, If, In,  Out, Main, Def, Return, Coma, Void,
    PuntoYComa, A_par, C_par, A_llave, C_llave, Op_aritmetico, Op_logico, Op_relacional, Op_booleano, String, ERROR;
non terminal P,  DECLS, DECL, INSTS, INST, ASIG, WHL, DCL, CND, ELS, IO, CALL, 
    RET, FUNCS, FUNC, DEFINICION, PARAMS, PARAMSP, PARAM, EXPRS, OPERADOR, LAMBDA;
non terminal Symbols.TYPE TYPE;
non terminal Symbols.EXPR EXPR;
non terminal Symbols.EXPRP EXPRP;
non terminal Symbols.ASIGNACION ASIGNACION;
non terminal Symbols.LITERAL LITERAL;

start with P;

P ::=
    DECLS:a Main A_llave INSTS C_llave FUNCS:r {: //Symbol main = new Symbol(sym.Main, "main"); RESULT = main; System.out.println(main.sym); :}
;
DECLS ::= 
    DECL PuntoYComa:v DECLS  {: // :} |
    LAMBDA /*{:  :}*/
;
DECL ::=
    Const TYPE Id ASIGNACION /*{:  :}*/ |
    TYPE:v1 Id:v2 ASIGNACION:v3  {: Symbols.DECL decl = new Symbols.DECL(v1.valor, v2, v3.asignacion); RESULT = decl;  :}
;
TYPE ::=
    Tipo:v {: Symbols.TYPE t = new Symbols.TYPE((v)); RESULT = t;:}
;
ASIGNACION ::=
    Igual EXPRP:v {:Symbols.ASIGNACION asig = new Symbols.ASIGNACION(v); RESULT = asig;  :} |
    LAMBDA /*{:  :}*/
;
INSTS ::=
    INST PuntoYComa INSTS /*{:  :}*/ |
    LAMBDA {: :}
;
INST ::=
    ASIG /*{:  :}*/ |
    WHL /*{:  :}*/ |
    DCL /*{:  :}*/ |
    CND /*{:  :}*/ |
    IO /*{:  :}*/ |
    CALL /*{:  :}*/ |
    RET /*{:  :}*/
;
ASIG ::=
    Id Igual EXPRP /*{:  :}*/
;
WHL ::=
    While A_par EXPRP C_par A_llave INSTS C_llave /*{:  :}*/
;

DCL ::= 
    TYPE Id ASIGNACION /*{:  :}*/
;
CND ::= 
    If A_par EXPRP C_par A_llave INSTS C_llave ELS /*{:  :}*/
;
ELS ::=
    Else CND /*{:  :}*/ |
    Else A_llave INSTS C_llave /*{:  :}*/ |
    LAMBDA /*{:  :}*/
;
IO ::= 
    In A_par Id C_par /*{:  :}*/ |
    Out A_par EXPRP C_par /*{:  :}*/
;
CALL ::=  
    Id A_par EXPRS C_par /*{:  :}*/ |
    Id A_par C_par /*{:  :}*/
;
RET ::= 
    Return EXPRP /*{:  :}*/
;
FUNCS ::= 
    FUNC FUNCS /*{:  :}*/ |
    LAMBDA /*{:  :}*/
;
FUNC ::= 
    DEFINICION Id A_par PARAMS C_par A_llave INSTS C_llave /*{:  :}*/
;
DEFINICION ::= 
    Def TYPE |  /*{:  :}*/
    Def Void /*{:  :}*/
;
PARAMS ::= 
    PARAM PARAMSP |  /*{:  :}*/
    LAMBDA /*{:  :}*/
;
PARAMSP ::= 
    Coma PARAM PARAMSP /*{:  :}*/ |
    LAMBDA /*{:  :}*/
;
PARAM ::= 
    TYPE Id /*{:  :}*/
;
EXPRP ::=  
    EXPRP OPERADOR EXPR /*{:  :}*/ |
    EXPR:v {:Symbols.EXPRP exprp = new Symbols.EXPRP(v); RESULT = exprp;  :}
;
EXPR ::= 
    CALL /*{:  :}*/ |
    Id:v {: Symbols.EXPR id = new Symbols.EXPR(v); RESULT = id; :} |
    LITERAL:v {: Symbols.EXPR id = new Symbols.EXPR(v.literal); RESULT = id; :}
;

LITERAL ::= 
    Op_booleano |  /*{:  :}*/
    String /*{:  :}*/ |
    Numero:v {: RESULT = new Symbols.LITERAL(v);  :}
;
EXPRS ::= 
    EXPR Coma EXPRS /*{:  :}*/ |
    EXPR /*{:  :}*/
;
OPERADOR ::=
    Op_aritmetico | {: //RESULT = new OPERADOR(v2.type, v2.value); :}
    Op_relacional | 
    Op_logico 
;
LAMBDA ::= /* empty */;