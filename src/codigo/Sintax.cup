package codigo;

import java_cup.runtime.Symbol;
action code {:
    TablaSimbolos ts = new TablaSimbolos();
:}
parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
}
:};

init with {:
    
    

:}
terminal String Tipo, Id, Numero, Op_booleano, String, Op_aritmetico, Op_logico, Op_relacional;
terminal While, Igual, Else,  Const, If, In,  Out, Main, Def, Return, Coma, Void,
    PuntoYComa, A_par, C_par, A_llave, C_llave;

non terminal Symbols.P P;
non terminal Symbols.DECLS DECLS;
non terminal Symbols.OPERADOR OPERADOR;
non terminal Symbols.LAMBDA LAMBDA;
non terminal Symbols.DECL DECL;
non terminal Symbols.TYPE TYPE;
non terminal Symbols.EXPR EXPR;
non terminal Symbols.EXPRP EXPRP;
non terminal Symbols.EXPRS EXPRS;
non terminal Symbols.ASIGNACION ASIGNACION;
non terminal Symbols.LITERAL LITERAL;
non terminal Symbols.DEFINICION DEFINICION;
non terminal Symbols.FUNC FUNC;
non terminal Symbols.FUNCS FUNCS;
non terminal Symbols.CALL CALL;
non terminal Symbols.PARAM PARAM;
non terminal Symbols.PARAMS PARAMS;
non terminal Symbols.PARAMSP PARAMSP;
non terminal Symbols.INSTS INSTS;
non terminal Symbols.INST INST;
non terminal Symbols.ASIG ASIG;
non terminal Symbols.WHL WHL;
non terminal Symbols.DCL DCL;
non terminal Symbols.CND CND;
non terminal Symbols.ELS ELS;
non terminal Symbols.IO IO;
non terminal Symbols.RET RET;

start with P;

P ::=
    DECLS:v1 Main A_llave INSTS:v2 C_llave FUNCS:v3     {: RESULT = new Symbols.P(v1, v2, v3); :}
;
DECLS ::= 
    DECL:v1 PuntoYComa:v DECLS:v2   {: RESULT = new Symbols.DECLS(v1, v2); :} |
    LAMBDA                          {: RESULT = new Symbols.DECLS(); :}
;
DECL ::=
    Const DCL:v         {: RESULT = new Symbols.DECL(v, true, ts); :} |
    DCL:v               {: RESULT = new Symbols.DECL(v,false,null); :}
;
TYPE ::=
    Tipo:v              {: RESULT = new Symbols.TYPE(v); :}
;
ASIGNACION ::=
    Igual EXPRP:v       {: RESULT = new Symbols.ASIGNACION(v); :} |
    LAMBDA              {: RESULT = new Symbols.ASIGNACION(); :}
;
INSTS ::=
    INST:v1 INSTS:v2    {: RESULT = new Symbols.INSTS(v1, v2); :} |
    LAMBDA              {: RESULT = new Symbols.INSTS(); :} 
;
INST ::=
    ASIG:v PuntoYComa     {: RESULT = new Symbols.INST(v, true ); :} |
    WHL:v                 {: RESULT = new Symbols.INST(v, false); :} |
    DCL:v PuntoYComa      {: RESULT = new Symbols.INST(v, true ); :} |
    CND:v                 {: RESULT = new Symbols.INST(v, false); :} |
    IO:v PuntoYComa       {: RESULT = new Symbols.INST(v, true ); :} |
    CALL:v PuntoYComa     {: RESULT = new Symbols.INST(v, true ); :} |
    RET:v PuntoYComa      {: RESULT = new Symbols.INST(v, true ); :}
;
ASIG ::=
    Id:v1 Igual EXPRP:v2            {: RESULT = new Symbols.ASIG(v1,v2,ts); :}
;
WHL ::=
    While A_par EXPRP:v1 C_par A_llave INSTS:v2 C_llave {: RESULT = new Symbols.WHL(v1, v2);  :}
;

DCL ::= 
    TYPE:v1 Id:v2 ASIGNACION:v3     {: RESULT = new Symbols.DCL(v1,v2, v3, ts); :}
;
CND ::= 
    If A_par EXPRP:v1 C_par A_llave INSTS:v2 C_llave ELS:v3 {: RESULT = new Symbols.CND(v1, v2, v3);  :}
;
ELS ::=
    Else CND:v                      {: RESULT = new Symbols.ELS(v); :} |
    Else A_llave INSTS:v C_llave    {: RESULT = new Symbols.ELS(v); :} |
    LAMBDA                          {: RESULT = new Symbols.ELS(); :}
;
IO ::= 
    In A_par Id:v C_par             {: RESULT = new Symbols.IO(v, ts); :} |
    Out A_par EXPRP:v C_par         {: RESULT = new Symbols.IO(v); :}
;
CALL ::=  
    Id:v1 A_par EXPRS:v2 C_par      {: RESULT = new Symbols.CALL(v1, v2, ts);  :} |
    Id:v A_par C_par                {: RESULT = new Symbols.CALL(v, ts); :}
;
RET ::= 
    Return EXPRP:v                  {: RESULT = new Symbols.RET(v); :}
;
FUNCS ::= 
    FUNC:v1 FUNCS:v2                {: RESULT = new Symbols.FUNCS(v1, v2); :} |
    LAMBDA                          {: RESULT = new Symbols.FUNCS(); :}
;
FUNC ::= 
    DEFINICION:v1 Id:v2 A_par PARAMS:v3 C_par A_llave INSTS:v4 C_llave {: RESULT = new Symbols.FUNC(v1,v2,v3,v4,ts); :}
;
DEFINICION ::= 
    Def TYPE:v                      {: RESULT = new Symbols.DEFINICION(v);  :} |
    Def Void                        {: RESULT = new Symbols.DEFINICION(); :}
;
PARAMS ::= 
    PARAM:v1 PARAMSP:v2             {: RESULT = new Symbols.PARAMS(v1,v2); :} |
    LAMBDA                          {: RESULT = new Symbols.PARAMS(); :}
;
PARAMSP ::= 
    Coma PARAM:v1 PARAMSP:v2        {: RESULT = new Symbols.PARAMSP(v1, v2); :} |
    LAMBDA                          {: RESULT = new Symbols.PARAMSP(); :}
;
PARAM ::= 
    TYPE:v1 Id:v2                   {: RESULT = new Symbols.PARAM(v1, v2); :}
;
EXPRP ::=  
    EXPRP:v1 OPERADOR:v2 EXPR:v3    {: RESULT = new Symbols.EXPRP(v1,v2,v3); :} |
    EXPR:v                          {: RESULT = new Symbols.EXPRP(v); :}
;
EXPR ::= 
    CALL:v                          {: RESULT = new Symbols.EXPR(v); :} |
    Id:v                            {: RESULT = new Symbols.EXPR(v, ts); :} |
    LITERAL:v                       {: RESULT = new Symbols.EXPR(v); :}
;

LITERAL ::= 
    Op_booleano:v                     {: RESULT = new Symbols.LITERAL(codigo.TablaSimbolos.Tipo.tBool,v); :} |
    String:v                          {: RESULT = new Symbols.LITERAL(codigo.TablaSimbolos.Tipo.tString, v); :} |
    Numero:v                          {: RESULT = new Symbols.LITERAL(codigo.TablaSimbolos.Tipo.tInt, v);  :}
;
EXPRS ::= 
    EXPRP:v1 Coma EXPRS:v2          {: RESULT = new Symbols.EXPRS(v1, v2); :} |
    EXPRP:v                         {: RESULT = new Symbols.EXPRS(v); :}
;
OPERADOR ::=
    Op_aritmetico:v                 {: RESULT = new Symbols.OPERADOR(v,1); :}| 
    Op_relacional:v                 {: RESULT = new Symbols.OPERADOR(v,2); :}| 
    Op_logico:v                     {: RESULT = new Symbols.OPERADOR(v,3); :}
;
LAMBDA ::= /* empty */;

